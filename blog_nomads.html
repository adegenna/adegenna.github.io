<!DOCTYPE html>
<html>
<head>
  <link href="prism.css" rel="stylesheet" />
</head>
<title>Blog: shape inference with level sets | Anthony M. DeGennaro</title>
<meta name="description" content="Research">
<meta name="keywords" content="uncertainty quantification, machine learning, scientific computing, low dimensional modeling,research">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/lib/w3.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<style>
body,h1,h2,h3,h4,h5,h6,.w3-navbar,h1,button {font-family: "Lato", sans-serif}
.fa-coffee {font-size:200px}
hr {
  margin-top: 0.01em;
  margin-bottom: 0.01em;
  border-width: 10px;
}
header {
  background-image: url("images/research.png");
  background-size: 871px 256px;
  max-width: 871px;
  margin: auto;
}
table {
  width: 100%;
  border-collapse: collapse;
  border: None;
  margin-top: 0px;
  font-family: "Lato", sans-serif;
}
.codebox {
  /* Below are styles for the codebox (not the code itself) */
  border:1px solid black;
  background-color:#EEEEFF;
  width:300px;
  overflow:auto;    
  padding:10px;
}
.codebox code {
  /* Styles in here affect the text of the codebox */
  font-size:0.9em;
  /* You could also put all sorts of styling here, like different font, color, underline, etc. for the code. */
}
</style>
<script src="prism.js"></script>
<body>

<!-- Navbar -->
<div class="w3-top">
  <ul class="w3-navbar w3-black w3-card-2 w3-left-align w3-large" style="background-color:#204e87">
    <li class="w3-hide-medium w3-hide-large w3-opennav w3-right">
      <a class="w3-padding-large w3-hover-white w3-large w3-black" href="javascript:void(0);" onclick="myFunction()" title="Toggle Navigation Menu"><i class="fa fa-bars"></i></a>
    </li>
    <li><a href="index.html" class="w3-padding-large w3-white">Anthony M. DeGennaro</a></li>
    <li class="w3-hide-small"><a href="research.html" class="w3-padding-large w3-hover-white">Research</a></li>
    <li class="w3-hide-small"><a href="blog.html" class="w3-padding-large w3-hover-white">Blog</a></li>
    <li class="w3-hide-small"><a href="programs.html" class="w3-padding-large w3-hover-white">Programming Projects</a></li>
    <li class="w3-hide-small"><a href="art.html" class="w3-padding-large w3-hover-white">Art and Writing</a></li>
  </ul>

  <!-- Navbar on small screens -->
  <div id="navDemo" class="w3-hide w3-hide-large w3-hide-medium">
    <ul class="w3-navbar w3-left-align w3-large w3-black">
      <li><a class="w3-padding-large" href="research.html">Research</a></li>
      <li><a class="w3-padding-large" href="blog.html">Blog</a></li>
      <li><a class="w3-padding-large" href="programs.html">Programming Projects</a></li>
      <li><a class="w3-padding-large" href="art.html">Art and Writing</a></li>
    </ul>
  </div>
</div>


<div class="w3-row-padding w3-padding-64 w3-container">
  <div class="w3-content">
      <h1>Should I stay or should I go?</h1>
      <h5>  
        It's 1200 BC, and you're a nomad.
        One fine day, you look around, and decide that where you live kind of sucks: it's dry and hot, and growing crops is hard.
        But more importantly, you notice signs that things might be a bit better 30 miles or so away, where a line of tall trees stand out, making you suspect the presence of a river.
        You and your tribe move there and discover that indeed, there is a river, and you settle down next to it.
        For a time, life is much easier.
      </h5>
      <h5>
        But soon, other dusty tribes from other corners of the surrounding desert begin to take notice as well.
        They move in, which makes the area stand out even more prominently, which attracts even more outsiders.
        Soon, the tiny river is swarming with nomad settlements; so many, in fact, that the river begins to get polluted, and the once lush surrounding land turns barren.
        Ironically, this once fertile oasis has become a victim of its own fertility. 
        This puts pressure on the nomads, some of whom leave, in search of the next best place.
        Some of the less intrepid settlers, on the other hand, decide to stay, reasoning that the land will rebound after these recent departures.
      </h5>
      <h5>
        And so, nomadic life is defined by this tension between stasis and movement. 
        Ideally, we'd all like to remain comfortable where we are, but when times are hard and the land is unworkable, that's not an option.
        In this post, I want to explore how we can model this sort of dynamic. 
        We'll of course look at pretty pictures and videos, but I'm hoping to also shed some light on the mathematical structures that drive this process.
      </h5>
  </div>
</div>
<hr>

<div class="w3-row-padding w3-padding-64 w3-container">
  <div class="w3-content">
      <h3>The overall vision</h3>
      <h5>
        We want to build an <em>agent-based model</em>, i.e. a model where a discrete number of nomads (agents) move throughout space and interact with each other and with the local terrain in some way.
        At any given moment in time, an agent will look at their surroundings and decide whether the land on which they're situated is good enough for them to settle or not.
        If it is, then they'll stop wandering, settle in, and form a "village"; if not, they'll continue wandering in search of better land.
        Here's where things get interesting: a village can degrade the quality of the land it sits on. 
        If that land degrades enough, the nomad that settled in that village can decide to disband it and continue on wandering.
        So, the dynamics evolve under two-way coupling: the terrain quality determines whether villages form, and the presence of villages determines the quality of the terrain.
      </h5>
  </div>
</div>
<hr>

<div class="w3-row-padding w3-padding-64 w3-container">
  <div class="w3-content">
      <h3>Version 1: static terrain</h3>
      <h5>
        The dynamics of our model will unfold on a static, structured 2D spatial grid \( G = \lbrace (x_i,y_j) \rbrace \), where \( i = 1 \dots n_x \) and \( j = 1 \dots n_y \).
        The <em>agents</em> will be described by their location on \(G\): \( A = \lbrace a_i \rbrace \; \text{for} \; i=1 \dots n_a \), where \( a_i \in G \).
        <em>Villages</em> will also be characterized in this way: \( V = \lbrace v_i \rbrace \; \text{for} \; i=1 \dots n_v \), where \( v_i \in G \).
        I'll be referring to \(a_i\) and \(v_i\) as both the agents/villages as entities and as their spatial locations interchangeably, so please excuse the slight abuse of notation.
        The <em>terrain quality</em> \( T(x,y) : \mathbb{R}^2 \mapsto \mathbb{R} \) is a spatial field defined on \( G \).
      </h5>
      <h5>
        With those basic definitions out of the way, let's talk about how the agents move about.
        At any given moment in time, agent \(a_i\) evaluates the quality of their terrain \( T(a_i) \).
        If \( T(a_i) \ge T^* \), then that agent "settles" to form a village.
        Algorithmically, this means that we pop the location \( a_i \) off of the set \(A\) and append it to the set \(V\).
        Otherwise, \( T(a_i) < T^* \), and the agent continues to wander.
        This wandering is modeled as a random process: the agent randomly chooses one of the 8 grid locations that neighbor \(a_i\), call it \( a_i^* \).
        If \( T(a_i^*) > T(a_i) \), then the agent moves to this "better" square; otherwise, it stays put with some probability.
        If it so happens that the agent stumbles onto a pre-existing village, they will just automatically decide to settle there.
      </h5>
      <h5>
        This is sufficient to define a "version 1" of our model; see below for an example simulation of it.
      </h5>
      <table>
        <tr>
          <td style="text-align:center; width:50%">
            <img src="movies/nomads_1.gif" alt="nomads 1" style="width:40%;" />
            <figure>
              <figcaption class="figure-caption text-center">
                <b>Version 1: evolution of nomads (<em>red</em>) towards forming villages (<em>blue</em>).</b>
              </figcaption>
            </figure>
          </td>
        </tr>
      </table>
      <h5>
        The terrain quality \( T(x,y) \) is represented in the inferno colorscale, with yellower colors being better.
        The simulation is initialized with randomly placed agents, and these wander about.
        We see the evolution of a long-term steady state: statistically speaking, the agents simply trace out the level set defined by \( T(x,y) = T^* \).
      </h5>
  </div>
</div>
<hr>

<div class="w3-row-padding w3-padding-64 w3-container">
  <div class="w3-content">
      <h3>Version 2: villages spawn new nomads</h3>
      <h5>
        The first addition we'll make is to allow villages to randomly spawn new agents with some probability.
      </h5>
      <table>
        <tr>
          <td style="text-align:center; width:50%">
            <img src="movies/nomads_2.gif" alt="nomads 2" style="width:40%;" />
            <figure>
              <figcaption class="figure-caption text-center">
                <b>Version 2: evolution of nomads (<em>red</em>) towards forming villages (<em>blue</em>). New nomads can spawn randomly adjacent to pre-existing villages.</b>
              </figcaption>
            </figure>
          </td>
        </tr>
      </table>
      <h5>
        This looks pretty similar to the previous version; the only difference is that the steady state is now defined by \( T(x,y) \ge T^* \).
        This is because of the new agents which spawn: previously, most of the villages were formed by agents who wandered progressively "uphill" toward yellower areas.
        These agents would settle as soon as they hit a location with a desirability on the \( T^* \) threshold.
        This still happens, but now, new agents can sometimes spawn at locations where \( T(x,y) > T^* \), which pushes the local front of villages "inward" until the entire blob of desirable terrain is occupied.
      </h5>
  </div>
</div>
<hr>


<div class="w3-row-padding w3-padding-64 w3-container">
  <div class="w3-content">
      <h3>Version 3: terrain degradation from village overpopulation</h3>
      <h5>
        Now we introduce a more interesting dynamic by coupling the terrain to the villages.
        The general idea is that if a local area is heavily populated with villages, then the resources should start to deplete and \( T(x,y) \) should decrease.
        We also allow for a resource-depleted area to regenerate over time, at a rate proportional to how depleted it is.
        This gives the following general system:
        \[ T_{g_i} \mapsto T_{g_i} - c_1 f_d( V , g_i ) + c_2 ( 1 - T_{g_i} ) \]
      </h5>
      <h5>
        where \( T_{g_i} \) denotes \(T\) at grid location \(g_i\) and \( f_d(V,g_i) \) is a function that estimates the density of villages at \( g_i \).
      </h5>
      <h5>
        There are several conceivable choices for the density function.
        One intuitive definition to consider is to average the number of villages in the vicinity of a grid point using a Gaussian weighting.
        This choice introduces natural locality and smoothness to the estimated density field.
        We can write this as:
        \[ f_d(V,\mathbf{g_i}) = \int_{\mathbf{x}} \mathbb{1}_v(\mathbf{x}) \mathcal{N}_{\sigma}( \| \mathbf{x} - \mathbf{g_i} \| ) d\mathbf{x} \]
        Notice this is the same as convolution with a kernel:
        \[ f_d(V,\mathbf{g_i}) = ( \mathbb{1}_v \star k )(\mathbf{g_i}) \]
        where, in this particular case, we've chosen the kernel to be Gaussian, i.e. \( k(\cdot) = \mathcal{N}_{\sigma}( \cdot ) \).
      </h5>
      <h5>
        Writing the density function as a convolution is a good idea for a couple reasons.
        First, it gives us a very convenient way to calculate it, since lots of libraries already exist for computing convolutions (especially these days with ML/AI).
        Second, it motivates the question: what about other choices of kernel?
        One thing that might be fun to do is to consider a kernel that in some sense has an opposite effect to that of a Gaussian.
        So, what's the general effect of a Gaussian kernel?
        </h5>
      <h5>
        To answer that question, it helps to introduce a bit of math, and connect kernels to the theory of partial differential equations (PDEs).
        It turns out that the Gaussian kernel is formally the <em>Green's function</em> of the heat equation:
        \[ u_t = \alpha \nabla^2 u \]
        A consequence of this is that the heat equation can be solved, given any initial condition, by convolution with a Gaussian kernel.
        What this means for us is that there is a deep connection between the Gaussian kernel and the behavior of the heat equation.
        We know that the heat equation produces very smooth solutions; sharp features are dulled down and everything sort of regresses to a global, boring average.
      </h5>
      <h5>
        So, the kernel we chose smooths things out. 
        What's the opposite of that?
        Motivated by the PDE theory we just discussed, we can "work backwards", starting with a PDE that we know has different behavior and asking what its Green's function is.
        The <em>Helmholtz equation</em> is a good candidate in this regard: 
        \[ (\nabla^2 - w^2)u = \delta(\mathbf{x}) \]
        Instead of smoothing, this equation tends to produce sharply defined, resonant spatial wavelengths.
        Its Green's function can be approximated by cosine-ripple functions that look like this:
        \[ k_h( \| \mathbf{x} - \mathbf{g_i} \| ) = \text{cos}(w \| \mathbf{x} - \mathbf{g_i} \| ) \text{exp}\left[ -\| \mathbf{x} - \mathbf{g_i} \|^2 / (2 \sigma^2)\right] \]        
      </h5>
      <h5>
        So, we can create a density function that combines these kernels:
        \[ f_d(V,\mathbf{g_i}) = ( \mathbb{1}_v \star (\alpha k_d + \beta k_h) )(\mathbf{g_i}) \]
        where \( k_d \) and \( k_h \) are the diffusion (heat) and Helmholtz kernels, respectively.
        With this combination, we can pit these two kernels against each other, producing dynamics that are a compromise between their opposing effects.
        If the diffusion kernel tears down order through homogenization, the Helmholtz kernel builds order through resonance.
      </h5>
      <h5>
        To see this, let's take a look below at what the behavior looks like for different values of \( \alpha,\beta\).
      </h5>
      <table>
        <tr>
          <td style="text-align:center; width:40%">
            <img src="movies/nomads_diff.gif" alt="nomads diff" style="width:90%;" />
            <figure>
              <figcaption class="figure-caption text-center">
                <b>Evolution under a pure diffusion kernel.</b>
              </figcaption>
            </figure>
          </td>
          <td style="text-align:center; width:40%">
            <img src="movies/nomads_helm.gif" alt="nomads helm" style="width:90%;" />
            <figure>
              <figcaption class="figure-caption text-center">
                <b>Evolution under a pure cosine-ripple kernel.</b>
              </figcaption>
            </figure>
          </td>
        </tr>
      </table>
      <h5>
        Now, let's see what happens when we combine the two and have them fight it out for order/chaos:
      </h5>
      <table>
        <tr>
          <td style="text-align:center; width:50%">
            <img src="movies/nomads_diff_and_helm.gif" alt="nomads diff/helm" style="width:40%;" />
            <figure>
              <figcaption class="figure-caption text-center">
                <b>Evolution for \( \alpha=1,\beta=0.3 \).</b>
              </figcaption>
            </figure>
          </td>
        </tr>
      </table>
  </div>
</div>
<hr>






<!-- Footer -->
<footer class="w3-container w3-padding-64 w3-center w3-opacity">  
  <div class="w3-xlarge w3-padding-32">
   <a href="https://www.linkedin.com/in/anthony-degennaro-69b272123/" class="w3-hover-text-indigo"><i class="fa fa-linkedin"></i></a>
 </div>
 <p>Powered by <a href="https://www.w3schools.com/w3css/default.asp" target="_blank">w3.css</a></p>
</footer>

<script>
// Used to toggle the menu on small screens when clicking on the menu button
function myFunction() {
    var x = document.getElementById("navDemo");
    if (x.className.indexOf("w3-show") == -1) {
        x.className += " w3-show";
    } else { 
        x.className = x.className.replace(" w3-show", "");
    }
}
</script>

</body>
</html>
